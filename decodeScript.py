"""Some functions for parsing a FIT file (specifically, a FIT file
generated by a Garmin vÃ­voactive 3) and creating a Pandas DataFrame
with the data.
"""

from datetime import datetime, timedelta
from typing import Dict, Union, Optional, Tuple
from gpxplotter import read_gpx_file, create_folium_map, add_segment_to_map, add_all_tiles
import folium
import pandas as pd

import fitdecode

# The names of the columns we will use in our points DataFrame. For the data we will be getting
# from the FIT data, we use the same name as the field names to make it easier to parse the data.
POINTS_COLUMN_NAMES = ['latitude', 'longitude', 'lap', 'altitude', 'timestamp', 'heart_rate', 'cadence', 'speed']

# The names of the columns we will use in our laps DataFrame. 
LAPS_COLUMN_NAMES = ['number', 'start_time', 'total_distance', 'total_elapsed_time',
                     'max_speed', 'max_heart_rate', 'avg_heart_rate']

def get_fit_lap_data(frame: fitdecode.records.FitDataMessage) -> Dict[str, Union[float, datetime, timedelta, int]]:
    """Extract some data from a FIT frame representing a lap and return
    it as a dict.
    """
    
    data: Dict[str, Union[float, datetime, timedelta, int]] = {}
    
    for field in LAPS_COLUMN_NAMES[1:]:  # Exclude 'number' (lap number) because we don't get that
                                        # from the data but rather count it ourselves
        if frame.has_field(field):
            data[field] = frame.get_value(field)
    
    return data

def get_fit_point_data(frame: fitdecode.records.FitDataMessage) -> Optional[Dict[str, Union[float, int, str, datetime]]]:
    """Extract some data from an FIT frame representing a track point
    and return it as a dict.
    """
    
    data: Dict[str, Union[float, int, str, datetime]] = {}
    
    if not (frame.has_field('position_lat') and frame.has_field('position_long')):
        # Frame does not have any latitude or longitude data. We will ignore these frames in order to keep things
        # simple, as we did when parsing the TCX file.
        return None
    else:
        data['latitude'] = frame.get_value('position_lat') / ((2**32) / 360)
        data['longitude'] = frame.get_value('position_long') / ((2**32) / 360)
    
    for field in POINTS_COLUMN_NAMES[3:]:
        if frame.has_field(field):
            data[field] = frame.get_value(field)
    
    return data
    

def get_dataframes(fname: str) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """Takes the path to a FIT file (as a string) and returns two Pandas
    DataFrames: one containing data about the laps, and one containing
    data about the individual points.
    """

    points_data = []
    laps_data = []
    lap_no = 1
    with fitdecode.FitReader(fname) as fit_file:
        for frame in fit_file:
            if isinstance(frame, fitdecode.records.FitDataMessage):
                if frame.name == 'record':
                    single_point_data = get_fit_point_data(frame)
                    if single_point_data is not None:
                        single_point_data['lap'] = lap_no
                        points_data.append(single_point_data)
                elif frame.name == 'lap':
                    single_lap_data = get_fit_lap_data(frame)
                    single_lap_data['number'] = lap_no
                    laps_data.append(single_lap_data)
                    lap_no += 1
    
    # Create DataFrames from the data we have collected. If any information is missing from a particular lap or track
    # point, it will show up as a null value or "NaN" in the DataFrame.
    
    laps_df = pd.DataFrame(laps_data, columns=LAPS_COLUMN_NAMES)
    laps_df.set_index('number', inplace=True)
    points_df = pd.DataFrame(points_data, columns=POINTS_COLUMN_NAMES)
    
    return laps_df, points_df

def parseTimestamp(string):
    t = string
    t = t.replace(' ', 'T')
    head, sep, tail = t.partition('+')
    t = head + 'Z'
    return(t)

def makeDataFrames(file):
    lapsDf, pointsDf = get_dataframes(file)
    return(pointsDf)

def makeGPX(df):
    gpxBegin = """<?xml version="1.0" encoding="UTF-8"?>
    <gpx creator="Garmin Connect" version="1.1"
    xsi:schemaLocation="http://www.topografix.com/GPX/1/1 http://www.topografix.com/GPX/11.xsd"
    xmlns:ns3="http://www.garmin.com/xmlschemas/TrackPointExtension/v1"
    xmlns="http://www.topografix.com/GPX/1/1"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ns2="http://www.garmin.com/xmlschemas/GpxExtensions/v3"> \n
    """
    
    time = datetime.today()

    gpxBegin += """
      <metadata> 
       <link href="http://www.garmin.com"> 
        <text>Garmin International</text> </link>
        <time>{}</time>
      </metadata>
    """.format(time)

    gpxBegin += '   <trk>\n    <trkseg>\n'

    for index, entry in df.iterrows():
        t = parseTimestamp(str(entry['timestamp']))
        lat = str(entry['latitude'])
        lon = str(entry['longitude'])
        alt = str(entry['altitude'])
        hr = str(entry['heart_rate'])
        cad = str(entry['cadence'])

        gpxBegin += '     <trkpt lat=' + '\"{}\"'.format(lat) + ' lon=' + '\"{}\"'.format(lon) + '> \n'
        gpxBegin += '      <ele>{}</ele>\n'.format(alt)
        gpxBegin += '      <time>{}</time>\n'.format(t)
        gpxBegin += '       <extensions>\n        <ns3:TrackPointExtension>\n'
        gpxBegin += '         <ns3:hr>{}</ns3:hr>\n'.format(hr)
        gpxBegin += '         <ns3:cad>{}</ns3:cad>\n'.format(cad)
        gpxBegin += '        </ns3:TrackPointExtension>\n       </extensions>\n'
        gpxBegin += '     </trkpt>\n'
        
    
    gpxBegin += '\n  </trkseg>\n </trk>\n</gpx>'

    #with open('parsed.txt', 'w') as f:
    #    f.write(gpxBegin)

    #with open('parsed.gpx', 'w') as gpx:
    #    gpx.write(gpxBegin)
    
    return(gpxBegin)

def makeMap(df, gpx):
    if(df.empty):
        return 0
    else:
        m = folium.Map(location=[df.loc[1, 'latitude'],  df.loc[1, 'longitude']], tiles = 'Stamen Toner', zoom_start=13)
        gpx.seek(0)
        for track in read_gpx_file(gpx.name):
            for i, segment in enumerate(track['segments']):
                add_segment_to_map(m, segment, color_by='elevation')

        add_all_tiles(m)

        folium.LayerControl(sortLayers=True).add_to(m)

        return(m)

    return 0

#if __name__ == '__main__':
    
    #fname = 'test.FIT'  # Path to FIT file to be given as first argument to script
    #laps_df, points_df = get_dataframes(fname)

    #df = makeDataFrames('test.FIT')
    #ddf = makeGPX(df)
    #print(df)
    

""" import tempfile
from gpxplotter import read_gpx_file, add_segment_to_map
import os

t = tempfile.NamedTemporaryFile(suffix = '.gpx', mode = 'w+', delete=False)
t.write(ddf)

m = folium.Map()


for track in read_gpx_file(t.name):
    for i, seg in enumerate(track['segments']):
        if(i < 10):
            print(seg)

t.close()
os.unlink(t.name) """